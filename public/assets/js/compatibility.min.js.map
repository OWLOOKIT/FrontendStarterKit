{"version":3,"sources":["console.js","picturefill.js"],"names":["window","console","log","matchMedia","styleMedia","media","style","document","createElement","script","getElementsByTagName","info","type","id","parentNode","insertBefore","getComputedStyle","currentStyle","matchMedium","text","styleSheet","cssText","textContent","width","matches","w","doc","image","expose","picturefill","module","exports","define","amd","opt","elements","element","parent","firstMatch","candidates","options","pf","getAllElements","i","plen","length","undefined","nodeName","toUpperCase","ns","reevaluate","evaluated","removeVideoShim","getMatch","sizesSupported","srcset","regWDesc","test","dodgeSrcset","processSourceSet","applyBestCandidate","runPicturefill","checkResize","clearTimeout","resizeTimer","setTimeout","handleResize","initTypeDetects","intervalId","setInterval","readyState","clearInterval","addEventListener","attachEvent","HTMLPictureElement","srcsetSupported","curSrcSupported","trim","str","replace","makeUrl","anchor","src","href","restrictsMixedContent","location","protocol","matchesMedia","getDpr","devicePixelRatio","getWidthFromLength","cssValue","indexOf","parseFloat","lengthEl","className","e","body","appendChild","offsetWidth","removeChild","detectTypeSupport","typeUri","Image","onerror","types","onload","implementation","hasFeature","verifyTypeSupport","source","getAttribute","pfType","parseSize","sourceSizeStr","match","exec","findWidthFromSourceSize","sourceSizeListStr","winningLength","sourceSizeList","split","len","sourceSize","parsedSize","Math","max","innerWidth","documentElement","clientWidth","parseSrcset","url","pos","search","descriptor","slice","last","descpos","push","parseDescriptor","sizesattr","resCandidate","sizes","sizeDescriptor","widthInCssPixels","splitDescriptor","curr","lastchar","res","isNaN","parseInt","getCandidatesFromSourceSet","formattedCandidates","candidate","resolution","img","setAttribute","el","backfaceVisibilityFix","picImg","WebkitBackfaceVisibility","currentZoom","zoom","setIntrinsicSize","urlCache","setSize","bestCandidate","pfStopIntrinsicSize","dims","sort","ascendingSort","substr","toLowerCase","warn","currentSrc","a","b","picture","videos","video","vsources","elems","imgs","h","currImg","sources","childNodes","j","slen","nodeType","typeSupported","_"],"mappings":"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","file":"compatibility.min.js","sourcesContent":["// Avoid `console` errors in browsers that lack a console.\n(function(window) {\n    var console = window.console = window.console || {};\n    console.log = console.log || function () {};\n})(window);\n","/*! Picturefill - v2.3.1 - 2015-04-09\n* http://scottjehl.github.io/picturefill\n* Copyright (c) 2015 https://github.com/scottjehl/picturefill/blob/master/Authors.txt; Licensed MIT */\n/*! matchMedia() polyfill - Test a CSS media type/query in JS. Authors & copyright (c) 2012: Scott Jehl, Paul Irish, Nicholas Zakas, David Knight. Dual MIT/BSD license */\n\nwindow.matchMedia || (window.matchMedia = function() {\n\t\"use strict\";\n\n\t// For browsers that support matchMedium api such as IE 9 and webkit\n\tvar styleMedia = (window.styleMedia || window.media);\n\n\t// For those that don't support matchMedium\n\tif (!styleMedia) {\n\t\tvar style       = document.createElement('style'),\n\t\t\tscript      = document.getElementsByTagName('script')[0],\n\t\t\tinfo        = null;\n\n\t\tstyle.type  = 'text/css';\n\t\tstyle.id    = 'matchmediajs-test';\n\n\t\tscript.parentNode.insertBefore(style, script);\n\n\t\t// 'style.currentStyle' is used by IE <= 8 and 'window.getComputedStyle' for all other browsers\n\t\tinfo = ('getComputedStyle' in window) && window.getComputedStyle(style, null) || style.currentStyle;\n\n\t\tstyleMedia = {\n\t\t\tmatchMedium: function(media) {\n\t\t\t\tvar text = '@media ' + media + '{ #matchmediajs-test { width: 1px; } }';\n\n\t\t\t\t// 'style.styleSheet' is used by IE <= 8 and 'style.textContent' for all other browsers\n\t\t\t\tif (style.styleSheet) {\n\t\t\t\t\tstyle.styleSheet.cssText = text;\n\t\t\t\t} else {\n\t\t\t\t\tstyle.textContent = text;\n\t\t\t\t}\n\n\t\t\t\t// Test if media query is true or false\n\t\t\t\treturn info.width === '1px';\n\t\t\t}\n\t\t};\n\t}\n\n\treturn function(media) {\n\t\treturn {\n\t\t\tmatches: styleMedia.matchMedium(media || 'all'),\n\t\t\tmedia: media || 'all'\n\t\t};\n\t};\n}());\n/*! Picturefill - Responsive Images that work today.\n*  Author: Scott Jehl, Filament Group, 2012 ( new proposal implemented by Shawn Jansepar )\n*  License: MIT/GPLv2\n*  Spec: http://picture.responsiveimages.org/\n*/\n(function( w, doc, image ) {\n\t// Enable strict mode\n\t\"use strict\";\n\n\tfunction expose(picturefill) {\n\t\t/* expose picturefill */\n\t\tif ( typeof module === \"object\" && typeof module.exports === \"object\" ) {\n\t\t\t// CommonJS, just export\n\t\t\tmodule.exports = picturefill;\n\t\t} else if ( typeof define === \"function\" && define.amd ) {\n\t\t\t// AMD support\n\t\t\tdefine( \"picturefill\", function() { return picturefill; } );\n\t\t}\n\t\tif ( typeof w === \"object\" ) {\n\t\t\t// If no AMD and we are in the browser, attach to window\n\t\t\tw.picturefill = picturefill;\n\t\t}\n\t}\n\n\t// If picture is supported, well, that's awesome. Let's get outta here...\n\tif ( w.HTMLPictureElement ) {\n\t\texpose(function() { });\n\t\treturn;\n\t}\n\n\t// HTML shim|v it for old IE (IE9 will still need the HTML video tag workaround)\n\tdoc.createElement( \"picture\" );\n\n\t// local object for method references and testing exposure\n\tvar pf = w.picturefill || {};\n\n\tvar regWDesc = /\\s+\\+?\\d+(e\\d+)?w/;\n\n\t// namespace\n\tpf.ns = \"picturefill\";\n\n\t// srcset support test\n\t(function() {\n\t\tpf.srcsetSupported = \"srcset\" in image;\n\t\tpf.sizesSupported = \"sizes\" in image;\n\t\tpf.curSrcSupported = \"currentSrc\" in image;\n\t})();\n\n\t// just a string trim workaround\n\tpf.trim = function( str ) {\n\t\treturn str.trim ? str.trim() : str.replace( /^\\s+|\\s+$/g, \"\" );\n\t};\n\n\t/**\n\t * Gets a string and returns the absolute URL\n\t * @param src\n\t * @returns {String} absolute URL\n\t */\n\tpf.makeUrl = (function() {\n\t\tvar anchor = doc.createElement( \"a\" );\n\t\treturn function(src) {\n\t\t\tanchor.href = src;\n\t\t\treturn anchor.href;\n\t\t};\n\t})();\n\n\t/**\n\t * Shortcut method for https://w3c.github.io/webappsec/specs/mixedcontent/#restricts-mixed-content ( for easy overriding in tests )\n\t */\n\tpf.restrictsMixedContent = function() {\n\t\treturn w.location.protocol === \"https:\";\n\t};\n\t/**\n\t * Shortcut method for matchMedia ( for easy overriding in tests )\n\t */\n\n\tpf.matchesMedia = function( media ) {\n\t\treturn w.matchMedia && w.matchMedia( media ).matches;\n\t};\n\n\t// Shortcut method for `devicePixelRatio` ( for easy overriding in tests )\n\tpf.getDpr = function() {\n\t\treturn ( w.devicePixelRatio || 1 );\n\t};\n\n\t/**\n\t * Get width in css pixel value from a \"length\" value\n\t * http://dev.w3.org/csswg/css-values-3/#length-value\n\t */\n\tpf.getWidthFromLength = function( length ) {\n\t\tvar cssValue;\n\t\t// If a length is specified and doesn’t contain a percentage, and it is greater than 0 or using `calc`, use it. Else, abort.\n        if ( !(length && length.indexOf( \"%\" ) > -1 === false && ( parseFloat( length ) > 0 || length.indexOf( \"calc(\" ) > -1 )) ) {\n            return false;\n        }\n\n\t\t/**\n\t\t * If length is specified in  `vw` units, use `%` instead since the div we’re measuring\n\t\t * is injected at the top of the document.\n\t\t *\n\t\t * TODO: maybe we should put this behind a feature test for `vw`? The risk of doing this is possible browser inconsistancies with vw vs %\n\t\t */\n\t\tlength = length.replace( \"vw\", \"%\" );\n\n\t\t// Create a cached element for getting length value widths\n\t\tif ( !pf.lengthEl ) {\n\t\t\tpf.lengthEl = doc.createElement( \"div\" );\n\n\t\t\t// Positioning styles help prevent padding/margin/width on `html` or `body` from throwing calculations off.\n\t\t\tpf.lengthEl.style.cssText = \"border:0;display:block;font-size:1em;left:0;margin:0;padding:0;position:absolute;visibility:hidden\";\n\n\t\t\t// Add a class, so that everyone knows where this element comes from\n\t\t\tpf.lengthEl.className = \"helper-from-picturefill-js\";\n\t\t}\n\n\t\tpf.lengthEl.style.width = \"0px\";\n\n        try {\n\t\t    pf.lengthEl.style.width = length;\n        } catch ( e ) {}\n\n\t\tdoc.body.appendChild(pf.lengthEl);\n\n\t\tcssValue = pf.lengthEl.offsetWidth;\n\n\t\tif ( cssValue <= 0 ) {\n\t\t\tcssValue = false;\n\t\t}\n\n\t\tdoc.body.removeChild( pf.lengthEl );\n\n\t\treturn cssValue;\n\t};\n\n    pf.detectTypeSupport = function( type, typeUri ) {\n        // based on Modernizr's lossless img-webp test\n        // note: asynchronous\n        var image = new w.Image();\n        image.onerror = function() {\n            pf.types[ type ] = false;\n            picturefill();\n        };\n        image.onload = function() {\n            pf.types[ type ] = image.width === 1;\n            picturefill();\n        };\n        image.src = typeUri;\n\n        return \"pending\";\n    };\n\t// container of supported mime types that one might need to qualify before using\n\tpf.types = pf.types || {};\n\n\tpf.initTypeDetects = function() {\n        // Add support for standard mime types\n        pf.types[ \"image/jpeg\" ] = true;\n        pf.types[ \"image/gif\" ] = true;\n        pf.types[ \"image/png\" ] = true;\n        pf.types[ \"image/svg+xml\" ] = doc.implementation.hasFeature(\"http://www.w3.org/TR/SVG11/feature#Image\", \"1.1\");\n        pf.types[ \"image/webp\" ] = pf.detectTypeSupport(\"image/webp\", \"data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA=\");\n    };\n\n\tpf.verifyTypeSupport = function( source ) {\n\t\tvar type = source.getAttribute( \"type\" );\n\t\t// if type attribute exists, return test result, otherwise return true\n\t\tif ( type === null || type === \"\" ) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\t\tvar pfType = pf.types[ type ];\n\t\t\t// if the type test is a function, run it and return \"pending\" status. The function will rerun picturefill on pending elements once finished.\n\t\t\tif ( typeof pfType === \"string\" && pfType !== \"pending\") {\n\t\t\t\tpf.types[ type ] = pf.detectTypeSupport( type, pfType );\n\t\t\t\treturn \"pending\";\n\t\t\t} else if ( typeof pfType === \"function\" ) {\n\t\t\t\tpfType();\n\t\t\t\treturn \"pending\";\n\t\t\t} else {\n\t\t\t\treturn pfType;\n\t\t\t}\n\t\t}\n\t};\n\n\t// Parses an individual `size` and returns the length, and optional media query\n\tpf.parseSize = function( sourceSizeStr ) {\n\t\tvar match = /(\\([^)]+\\))?\\s*(.+)/g.exec( sourceSizeStr );\n\t\treturn {\n\t\t\tmedia: match && match[1],\n\t\t\tlength: match && match[2]\n\t\t};\n\t};\n\n\t// Takes a string of sizes and returns the width in pixels as a number\n\tpf.findWidthFromSourceSize = function( sourceSizeListStr ) {\n\t\t// Split up source size list, ie ( max-width: 30em ) 100%, ( max-width: 50em ) 50%, 33%\n\t\t//                            or (min-width:30em) calc(30% - 15px)\n\t\tvar sourceSizeList = pf.trim( sourceSizeListStr ).split( /\\s*,\\s*/ ),\n\t\t\twinningLength;\n\n\t\tfor ( var i = 0, len = sourceSizeList.length; i < len; i++ ) {\n\t\t\t// Match <media-condition>? length, ie ( min-width: 50em ) 100%\n\t\t\tvar sourceSize = sourceSizeList[ i ],\n\t\t\t\t// Split \"( min-width: 50em ) 100%\" into separate strings\n\t\t\t\tparsedSize = pf.parseSize( sourceSize ),\n\t\t\t\tlength = parsedSize.length,\n\t\t\t\tmedia = parsedSize.media;\n\n\t\t\tif ( !length ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// if there is no media query or it matches, choose this as our winning length\n\t\t\tif ( (!media || pf.matchesMedia( media )) &&\n\t\t\t\t// pass the length to a method that can properly determine length\n\t\t\t\t// in pixels based on these formats: http://dev.w3.org/csswg/css-values-3/#length-value\n\t\t\t\t(winningLength = pf.getWidthFromLength( length )) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t//if we have no winningLength fallback to 100vw\n\t\treturn winningLength || Math.max(w.innerWidth || 0, doc.documentElement.clientWidth);\n\t};\n\n\tpf.parseSrcset = function( srcset ) {\n\t\t/**\n\t\t * A lot of this was pulled from Boris Smus’ parser for the now-defunct WHATWG `srcset`\n\t\t * https://github.com/borismus/srcset-polyfill/blob/master/js/srcset-info.js\n\t\t *\n\t\t * 1. Let input (`srcset`) be the value passed to this algorithm.\n\t\t * 2. Let position be a pointer into input, initially pointing at the start of the string.\n\t\t * 3. Let raw candidates be an initially empty ordered list of URLs with associated\n\t\t *    unparsed descriptors. The order of entries in the list is the order in which entries\n\t\t *    are added to the list.\n\t\t */\n\t\tvar candidates = [];\n\n\t\twhile ( srcset !== \"\" ) {\n\t\t\tsrcset = srcset.replace( /^\\s+/g, \"\" );\n\n\t\t\t// 5. Collect a sequence of characters that are not space characters, and let that be url.\n\t\t\tvar pos = srcset.search(/\\s/g),\n\t\t\t\turl, descriptor = null;\n\n\t\t\tif ( pos !== -1 ) {\n\t\t\t\turl = srcset.slice( 0, pos );\n\n\t\t\t\tvar last = url.slice(-1);\n\n\t\t\t\t// 6. If url ends with a U+002C COMMA character (,), remove that character from url\n\t\t\t\t// and let descriptors be the empty string. Otherwise, follow these substeps\n\t\t\t\t// 6.1. If url is empty, then jump to the step labeled descriptor parser.\n\n\t\t\t\tif ( last === \",\" || url === \"\" ) {\n\t\t\t\t\turl = url.replace( /,+$/, \"\" );\n\t\t\t\t\tdescriptor = \"\";\n\t\t\t\t}\n\t\t\t\tsrcset = srcset.slice( pos + 1 );\n\n\t\t\t\t// 6.2. Collect a sequence of characters that are not U+002C COMMA characters (,), and\n\t\t\t\t// let that be descriptors.\n\t\t\t\tif ( descriptor === null ) {\n\t\t\t\t\tvar descpos = srcset.indexOf( \",\" );\n\t\t\t\t\tif ( descpos !== -1 ) {\n\t\t\t\t\t\tdescriptor = srcset.slice( 0, descpos );\n\t\t\t\t\t\tsrcset = srcset.slice( descpos + 1 );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdescriptor = srcset;\n\t\t\t\t\t\tsrcset = \"\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\turl = srcset;\n\t\t\t\tsrcset = \"\";\n\t\t\t}\n\n\t\t\t// 7. Add url to raw candidates, associated with descriptors.\n\t\t\tif ( url || descriptor ) {\n\t\t\t\tcandidates.push({\n\t\t\t\t\turl: url,\n\t\t\t\t\tdescriptor: descriptor\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn candidates;\n\t};\n\n\tpf.parseDescriptor = function( descriptor, sizesattr ) {\n\t\t// 11. Descriptor parser: Let candidates be an initially empty source set. The order of entries in the list\n\t\t// is the order in which entries are added to the list.\n\t\tvar sizes = sizesattr || \"100vw\",\n\t\t\tsizeDescriptor = descriptor && descriptor.replace( /(^\\s+|\\s+$)/g, \"\" ),\n\t\t\twidthInCssPixels = pf.findWidthFromSourceSize( sizes ),\n\t\t\tresCandidate;\n\n\t\t\tif ( sizeDescriptor ) {\n\t\t\t\tvar splitDescriptor = sizeDescriptor.split(\" \");\n\n\t\t\t\tfor (var i = splitDescriptor.length - 1; i >= 0; i--) {\n\t\t\t\t\tvar curr = splitDescriptor[ i ],\n\t\t\t\t\t\tlastchar = curr && curr.slice( curr.length - 1 );\n\n\t\t\t\t\tif ( ( lastchar === \"h\" || lastchar === \"w\" ) && !pf.sizesSupported ) {\n\t\t\t\t\t\tresCandidate = parseFloat( ( parseInt( curr, 10 ) / widthInCssPixels ) );\n\t\t\t\t\t} else if ( lastchar === \"x\" ) {\n\t\t\t\t\t\tvar res = curr && parseFloat( curr, 10 );\n\t\t\t\t\t\tresCandidate = res && !isNaN( res ) ? res : 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\treturn resCandidate || 1;\n\t};\n\n\t/**\n\t * Takes a srcset in the form of url/\n\t * ex. \"images/pic-medium.png 1x, images/pic-medium-2x.png 2x\" or\n\t *     \"images/pic-medium.png 400w, images/pic-medium-2x.png 800w\" or\n\t *     \"images/pic-small.png\"\n\t * Get an array of image candidates in the form of\n\t *      {url: \"/foo/bar.png\", resolution: 1}\n\t * where resolution is http://dev.w3.org/csswg/css-values-3/#resolution-value\n\t * If sizes is specified, resolution is calculated\n\t */\n\tpf.getCandidatesFromSourceSet = function( srcset, sizes ) {\n\t\tvar candidates = pf.parseSrcset( srcset ),\n\t\t\tformattedCandidates = [];\n\n\t\tfor ( var i = 0, len = candidates.length; i < len; i++ ) {\n\t\t\tvar candidate = candidates[ i ];\n\n\t\t\tformattedCandidates.push({\n\t\t\t\turl: candidate.url,\n\t\t\t\tresolution: pf.parseDescriptor( candidate.descriptor, sizes )\n\t\t\t});\n\t\t}\n\t\treturn formattedCandidates;\n\t};\n\n\t/**\n\t * if it's an img element and it has a srcset property,\n\t * we need to remove the attribute so we can manipulate src\n\t * (the property's existence infers native srcset support, and a srcset-supporting browser will prioritize srcset's value over our winning picture candidate)\n\t * this moves srcset's value to memory for later use and removes the attr\n\t */\n\tpf.dodgeSrcset = function( img ) {\n\t\tif ( img.srcset ) {\n\t\t\timg[ pf.ns ].srcset = img.srcset;\n\t\t\timg.srcset = \"\";\n\t\t\timg.setAttribute( \"data-pfsrcset\", img[ pf.ns ].srcset );\n\t\t}\n\t};\n\n\t// Accept a source or img element and process its srcset and sizes attrs\n\tpf.processSourceSet = function( el ) {\n\t\tvar srcset = el.getAttribute( \"srcset\" ),\n\t\t\tsizes = el.getAttribute( \"sizes\" ),\n\t\t\tcandidates = [];\n\n\t\t// if it's an img element, use the cached srcset property (defined or not)\n\t\tif ( el.nodeName.toUpperCase() === \"IMG\" && el[ pf.ns ] && el[ pf.ns ].srcset ) {\n\t\t\tsrcset = el[ pf.ns ].srcset;\n\t\t}\n\n\t\tif ( srcset ) {\n\t\t\tcandidates = pf.getCandidatesFromSourceSet( srcset, sizes );\n\t\t}\n\t\treturn candidates;\n\t};\n\n\tpf.backfaceVisibilityFix = function( picImg ) {\n\t\t// See: https://github.com/scottjehl/picturefill/issues/332\n\t\tvar style = picImg.style || {},\n\t\t\tWebkitBackfaceVisibility = \"webkitBackfaceVisibility\" in style,\n\t\t\tcurrentZoom = style.zoom;\n\n\t\tif (WebkitBackfaceVisibility) {\n\t\t\tstyle.zoom = \".999\";\n\n\t\t\tWebkitBackfaceVisibility = picImg.offsetWidth;\n\n\t\t\tstyle.zoom = currentZoom;\n\t\t}\n\t};\n\n\tpf.setIntrinsicSize = (function() {\n\t\tvar urlCache = {};\n\t\tvar setSize = function( picImg, width, res ) {\n            if ( width ) {\n\t\t\t    picImg.setAttribute( \"width\", parseInt(width / res, 10) );\n            }\n\t\t};\n\t\treturn function( picImg, bestCandidate ) {\n\t\t\tvar img;\n\t\t\tif ( !picImg[ pf.ns ] || w.pfStopIntrinsicSize ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( picImg[ pf.ns ].dims === undefined ) {\n\t\t\t\tpicImg[ pf.ns].dims = picImg.getAttribute(\"width\") || picImg.getAttribute(\"height\");\n\t\t\t}\n\t\t\tif ( picImg[ pf.ns].dims ) { return; }\n\n\t\t\tif ( bestCandidate.url in urlCache ) {\n\t\t\t\tsetSize( picImg, urlCache[bestCandidate.url], bestCandidate.resolution );\n\t\t\t} else {\n\t\t\t\timg = doc.createElement( \"img\" );\n\t\t\t\timg.onload = function() {\n\t\t\t\t\turlCache[bestCandidate.url] = img.width;\n\n                    //IE 10/11 don't calculate width for svg outside document\n                    if ( !urlCache[bestCandidate.url] ) {\n                        try {\n                            doc.body.appendChild( img );\n                            urlCache[bestCandidate.url] = img.width || img.offsetWidth;\n                            doc.body.removeChild( img );\n                        } catch(e){}\n                    }\n\n\t\t\t\t\tif ( picImg.src === bestCandidate.url ) {\n\t\t\t\t\t\tsetSize( picImg, urlCache[bestCandidate.url], bestCandidate.resolution );\n\t\t\t\t\t}\n\t\t\t\t\tpicImg = null;\n\t\t\t\t\timg.onload = null;\n\t\t\t\t\timg = null;\n\t\t\t\t};\n\t\t\t\timg.src = bestCandidate.url;\n\t\t\t}\n\t\t};\n\t})();\n\n\tpf.applyBestCandidate = function( candidates, picImg ) {\n\t\tvar candidate,\n\t\t\tlength,\n\t\t\tbestCandidate;\n\n\t\tcandidates.sort( pf.ascendingSort );\n\n\t\tlength = candidates.length;\n\t\tbestCandidate = candidates[ length - 1 ];\n\n\t\tfor ( var i = 0; i < length; i++ ) {\n\t\t\tcandidate = candidates[ i ];\n\t\t\tif ( candidate.resolution >= pf.getDpr() ) {\n\t\t\t\tbestCandidate = candidate;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif ( bestCandidate ) {\n\n\t\t\tbestCandidate.url = pf.makeUrl( bestCandidate.url );\n\n\t\t\tif ( picImg.src !== bestCandidate.url ) {\n\t\t\t\tif ( pf.restrictsMixedContent() && bestCandidate.url.substr(0, \"http:\".length).toLowerCase() === \"http:\" ) {\n\t\t\t\t\tif ( window.console !== undefined ) {\n\t\t\t\t\t\tconsole.warn( \"Blocked mixed content image \" + bestCandidate.url );\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpicImg.src = bestCandidate.url;\n\t\t\t\t\t// currentSrc attribute and property to match\n\t\t\t\t\t// http://picture.responsiveimages.org/#the-img-element\n\t\t\t\t\tif ( !pf.curSrcSupported ) {\n\t\t\t\t\t\tpicImg.currentSrc = picImg.src;\n\t\t\t\t\t}\n\n\t\t\t\t\tpf.backfaceVisibilityFix( picImg );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpf.setIntrinsicSize(picImg, bestCandidate);\n\t\t}\n\t};\n\n\tpf.ascendingSort = function( a, b ) {\n\t\treturn a.resolution - b.resolution;\n\t};\n\n\t/**\n\t * In IE9, <source> elements get removed if they aren't children of\n\t * video elements. Thus, we conditionally wrap source elements\n\t * using <!--[if IE 9]><video style=\"display: none;\"><![endif]-->\n\t * and must account for that here by moving those source elements\n\t * back into the picture element.\n\t */\n\tpf.removeVideoShim = function( picture ) {\n\t\tvar videos = picture.getElementsByTagName( \"video\" );\n\t\tif ( videos.length ) {\n\t\t\tvar video = videos[ 0 ],\n\t\t\t\tvsources = video.getElementsByTagName( \"source\" );\n\t\t\twhile ( vsources.length ) {\n\t\t\t\tpicture.insertBefore( vsources[ 0 ], video );\n\t\t\t}\n\t\t\t// Remove the video element once we're finished removing its children\n\t\t\tvideo.parentNode.removeChild( video );\n\t\t}\n\t};\n\n\t/**\n\t * Find all `img` elements, and add them to the candidate list if they have\n\t * a `picture` parent, a `sizes` attribute in basic `srcset` supporting browsers,\n\t * a `srcset` attribute at all, and they haven’t been evaluated already.\n\t */\n\tpf.getAllElements = function() {\n\t\tvar elems = [],\n\t\t\timgs = doc.getElementsByTagName( \"img\" );\n\n\t\tfor ( var h = 0, len = imgs.length; h < len; h++ ) {\n\t\t\tvar currImg = imgs[ h ];\n\n\t\t\tif ( currImg.parentNode.nodeName.toUpperCase() === \"PICTURE\" ||\n\t\t\t( currImg.getAttribute( \"srcset\" ) !== null ) || currImg[ pf.ns ] && currImg[ pf.ns ].srcset !== null ) {\n\t\t\t\telems.push( currImg );\n\t\t\t}\n\t\t}\n\t\treturn elems;\n\t};\n\n\tpf.getMatch = function( img, picture ) {\n\t\tvar sources = picture.childNodes,\n\t\t\tmatch;\n\n\t\t// Go through each child, and if they have media queries, evaluate them\n\t\tfor ( var j = 0, slen = sources.length; j < slen; j++ ) {\n\t\t\tvar source = sources[ j ];\n\n\t\t\t// ignore non-element nodes\n\t\t\tif ( source.nodeType !== 1 ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Hitting the `img` element that started everything stops the search for `sources`.\n\t\t\t// If no previous `source` matches, the `img` itself is evaluated later.\n\t\t\tif ( source === img ) {\n\t\t\t\treturn match;\n\t\t\t}\n\n\t\t\t// ignore non-`source` nodes\n\t\t\tif ( source.nodeName.toUpperCase() !== \"SOURCE\" ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// if it's a source element that has the `src` property set, throw a warning in the console\n\t\t\tif ( source.getAttribute( \"src\" ) !== null && typeof console !== undefined ) {\n\t\t\t\tconsole.warn(\"The `src` attribute is invalid on `picture` `source` element; instead, use `srcset`.\");\n\t\t\t}\n\n\t\t\tvar media = source.getAttribute( \"media\" );\n\n\t\t\t// if source does not have a srcset attribute, skip\n\t\t\tif ( !source.getAttribute( \"srcset\" ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// if there's no media specified, OR w.matchMedia is supported\n\t\t\tif ( ( !media || pf.matchesMedia( media ) ) ) {\n\t\t\t\tvar typeSupported = pf.verifyTypeSupport( source );\n\n\t\t\t\tif ( typeSupported === true ) {\n\t\t\t\t\tmatch = source;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if ( typeSupported === \"pending\" ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn match;\n\t};\n\n\tfunction picturefill( opt ) {\n\t\tvar elements,\n\t\t\telement,\n\t\t\tparent,\n\t\t\tfirstMatch,\n\t\t\tcandidates,\n\t\t\toptions = opt || {};\n\n\t\telements = options.elements || pf.getAllElements();\n\n\t\t// Loop through all elements\n\t\tfor ( var i = 0, plen = elements.length; i < plen; i++ ) {\n\t\t\telement = elements[ i ];\n\t\t\tparent = element.parentNode;\n\t\t\tfirstMatch = undefined;\n\t\t\tcandidates = undefined;\n\n\t\t\t// immediately skip non-`img` nodes\n\t\t\tif ( element.nodeName.toUpperCase() !== \"IMG\" ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// expando for caching data on the img\n\t\t\tif ( !element[ pf.ns ] ) {\n\t\t\t\telement[ pf.ns ] = {};\n\t\t\t}\n\n\t\t\t// if the element has already been evaluated, skip it unless\n\t\t\t// `options.reevaluate` is set to true ( this, for example,\n\t\t\t// is set to true when running `picturefill` on `resize` ).\n\t\t\tif ( !options.reevaluate && element[ pf.ns ].evaluated ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// if `img` is in a `picture` element\n\t\t\tif ( parent && parent.nodeName.toUpperCase() === \"PICTURE\" ) {\n\n\t\t\t\t// IE9 video workaround\n\t\t\t\tpf.removeVideoShim( parent );\n\n\t\t\t\t// return the first match which might undefined\n\t\t\t\t// returns false if there is a pending source\n\t\t\t\t// TODO the return type here is brutal, cleanup\n\t\t\t\tfirstMatch = pf.getMatch( element, parent );\n\n\t\t\t\t// if any sources are pending in this picture due to async type test(s)\n\t\t\t\t// remove the evaluated attr and skip for now ( the pending test will\n\t\t\t\t// rerun picturefill on this element when complete)\n\t\t\t\tif ( firstMatch === false ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfirstMatch = undefined;\n\t\t\t}\n\n\t\t\t// Cache and remove `srcset` if present and we’re going to be doing `picture`/`srcset`/`sizes` polyfilling to it.\n\t\t\tif ( ( parent && parent.nodeName.toUpperCase() === \"PICTURE\" ) ||\n\t\t\t( !pf.sizesSupported && ( element.srcset && regWDesc.test( element.srcset ) ) ) ) {\n\t\t\t\tpf.dodgeSrcset( element );\n\t\t\t}\n\n\t\t\tif ( firstMatch ) {\n\t\t\t\tcandidates = pf.processSourceSet( firstMatch );\n\t\t\t\tpf.applyBestCandidate( candidates, element );\n\t\t\t} else {\n\t\t\t\t// No sources matched, so we’re down to processing the inner `img` as a source.\n\t\t\t\tcandidates = pf.processSourceSet( element );\n\n\t\t\t\tif ( element.srcset === undefined || element[ pf.ns ].srcset ) {\n\t\t\t\t\t// Either `srcset` is completely unsupported, or we need to polyfill `sizes` functionality.\n\t\t\t\t\tpf.applyBestCandidate( candidates, element );\n\t\t\t\t} // Else, resolution-only `srcset` is supported natively.\n\t\t\t}\n\n\t\t\t// set evaluated to true to avoid unnecessary reparsing\n\t\t\telement[ pf.ns ].evaluated = true;\n\t\t}\n\t}\n\n\t/**\n\t * Sets up picture polyfill by polling the document and running\n\t * the polyfill every 250ms until the document is ready.\n\t * Also attaches picturefill on resize\n\t */\n\tfunction runPicturefill() {\n\t\tpf.initTypeDetects();\n\t\tpicturefill();\n\t\tvar intervalId = setInterval( function() {\n\t\t\t// When the document has finished loading, stop checking for new images\n\t\t\t// https://github.com/ded/domready/blob/master/ready.js#L15\n\t\t\tpicturefill();\n\n\t\t\tif ( /^loaded|^i|^c/.test( doc.readyState ) ) {\n\t\t\t\tclearInterval( intervalId );\n\t\t\t\treturn;\n\t\t\t}\n\t\t}, 250 );\n\n\t\tvar resizeTimer;\n\t\tvar handleResize = function() {\n\t        picturefill({ reevaluate: true });\n\t    };\n\t\tfunction checkResize() {\n\t\t    clearTimeout(resizeTimer);\n\t\t    resizeTimer = setTimeout( handleResize, 60 );\n\t\t}\n\n\t\tif ( w.addEventListener ) {\n\t\t\tw.addEventListener( \"resize\", checkResize, false );\n\t\t} else if ( w.attachEvent ) {\n\t\t\tw.attachEvent( \"onresize\", checkResize );\n\t\t}\n\t}\n\n\trunPicturefill();\n\n\t/* expose methods for testing */\n\tpicturefill._ = pf;\n\n\texpose( picturefill );\n\n} )( window, window.document, new window.Image() );\n"],"sourceRoot":"/source/"}